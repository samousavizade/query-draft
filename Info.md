<div dir="rtl" style="text-align:right; line-height:1.9; font-size:16px">

<h2>چرا این انتخاب‌ها یهتر هستند؟</h2>

<h3>۱) افزودن معماری RAG (پایگاه داده برداری) به‌جای خوراندن کل اسکیما به LLM</h3>
<ul>
  <li><b>دقت بالاتر، هذیان کمتر:</b> فقط «تکه‌های مرتبطِ اسکیما» به مدل می‌رسند؛ مدل سراغ جدول/ستون‌های ناموجود نمی‌رود.</li>
  <li><b>کارایی و صرفه‌جویی در توکن:</b> به‌جای پرامپت‌های بزرگ، یک جست‌وجوی برداری سبک + چند قطعهٔ کوتاه.</li>
  <li><b>مقیاس‌پذیری با رشد اسکیما:</b> حتی با صدها جدول، هزینهٔ پرسش با <code>top-k retrieval</code> تقریباً ثابت می‌ماند.</li>
</ul>

<h3>۲) استفاده از FastAPI به‌جای Django در این سناریو</h3>
<ul>
  <li><b>سبک و سریع برای API خالص:</b> اینجا قالب/ادمین/ORM سنگین نمی‌خواهیم؛ یک سرویس API واکنشی می‌خواهیم.</li>
  <li><b>Async واقعی:</b> ادغام عالی با <code>httpx</code>، ران‌تایم async و LangGraph برای موازی‌سازی درخواست‌ها.</li>
  <li><b>توسعهٔ چابک:</b> تایپ‌های پایتون + Pydantic → اعتبارسنجی ورودی/خروجی و تولید خودکار OpenAPI/Swagger.</li>
  <li><b>حداقل کد پوسته:</b> برای موتور NL→SQL کوچک، FastAPI کمترین اصطکاک و دیپلوی ساده در کانتینر را دارد.</li>
  <li><b>انعطاف معماری:</b> چسباندن نودهای LangGraph، LLM، Qdrant و Postgres بدون محدودیت‌های یک فریم‌ورک فول‌استک.</li>
</ul>

<h3>۳) استفاده از Streamlit برای فرانت‌اند به‌جای HTML/JS ساده</h3>
<ul>
  <li><b>توسعهٔ فوق‌سریع:</b> بدون یک خط جاوااسکریپت، فرم سؤال، نمایش SQL و جدول نتایج را می‌سازید.</li>
  <li><b>مولفه‌های داده‌محور آماده:</b> DataFrame، فیلتر، دانلود CSV/XLSX، کش و state سِشن از پیش فراهم است.</li>
  <li><b>از نمونه‌سازی تا ابزار داخلی:</b> برای پنل تحلیلی تیم داده/بک‌اند کافی و کم‌هزینه است.</li>
  <li><b>نگهداشت کمتر:</b> کد کمتر ⇒ باگ کمتر؛ تمرکز روی منطق RAG/Agent به‌جای فرانت‌اند.</li>
</ul>
